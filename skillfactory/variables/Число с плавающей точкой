Перейти к основному содержимому
рисунок
Целые числа
Ранее мы познакомились с основными типами данных. Они, помимо прочего, представлены типами int (целые числа) и float (числа с плавающей точкой). В этом юните рассмотрим численные типы более подробно, их сходства и отличия, а также способы преобразования объектов одного типа в другой.

Множество целых чисел представлено натуральными числами (1, 2, 3, 4 и т. д.), противоположными им (-1, - 2, - 3 и т. д.), а также нулём. С некоторыми операциями над ними мы уже познакомились — знакомые всем арифметические операции: сложение, вычитание, умножение и возведение в степень. Операция деления для целых чисел имеет свои особенности.

Посмотрим, как будут вести себя целые числа при использовании «обычного» деления:

a = 5/2
print(a)
# 2.5
Как можем видеть, результатом такого деления стало число с плавающей точкой. Для получения целого числа как результата деления используется две специфические операции — целочисленное деление и взятие остатка от деления.

Операция целочисленного деления // возвращает целую часть получившегося результата, отбрасывая всю дробную часть. Приведём несколько примеров:

print(1 // 3)
# 0
print(3 // 3)
# 1
print(29 // 3)
# 9
В последнем примере можно заметить, что происходит не округление, а именно отбрасывание дробной части. Если обратиться к точному результату деления чисел 29 и 3, то можно увидеть, что его результат — 9.6666. Это число ближе к 10, и по правилам математического округления должно округляться вправо, но происходит полное отбрасывание дробной части.

О величине самой дробной части или, если быть точным, об остатке от деления, можно судить по результату операции %. Остаток от деления показывает, на сколько делимое больше ближайшего числа, которое делится нацело:

print(1 % 3) # ближайшее число, которое нацело делится на 3 - это ноль
# 1
print(3 % 3) # в этом примере сам делитель может нацело разделиться
# 0
print(29 % 3) # здесь ближайшее число - 27, и поэтому результат 29-27=2
# 2
Давайте ещё раз посмотрим на все арифметические операции, которые можно применять к целым числам:

Операция	Обозначение	Пример
Сложение	+	7+5 = 12
Разность	-	7-5 = 2
Умножение	*	7*5 = 35
Возведение в степень	**	7**5 = 16807
Целочисленное деление	//	7 // 5 = 1
Остаток от деления	%	7 % 5 = 2
Достаточно часто эти операции включены как часть более крупных математических выражений, поэтому необходимо помнить о приоритете выполнения операций, знакомых со школьной скамьи.

Если приоритеты не регулируются скобками, то арифметические операции будут выполняться в следующем порядке:

возведение в степень;
умножение, целочисленное деление и остаток от деления;
сложение и вычитание.
И аналогично таким же правилам в математике, если подряд идут несколько операторов одного приоритета, то вычисления выполняются слева направо.

Отдельно отметим особенность операций целочисленного деления и нахождения остатка от деления в случае отрицательных чисел.

Общее правило, по которому находится частное и остаток, можно сформулировать следующим образом. Если a — делимое, b — делитель, q — частное, а r — остаток, то:

q, r определяются из формулы: a = b*q+r.
r — отрицательно, если делитель меньше нуля, иначе r — неотрицательно, т.е. больше нуля или равно ему, но строго меньше числа b. Иными словами, если мы делим, скажем, на 4, то остаток может быть равен 0, 1, 2 или 3.
Давайте посмотрим на это правило на примере. В случае положительных чисел:

a = 5
b = 2
q = a // b # q = 2
r = a % b  # r = 1
Получили результат, согласующийся с формулой: максимально близкое число, на которое можно разделить нацело — это 2, и остаток в таком случае равен 1.

Посмотрим на несколько другую ситуацию:

a = -5
b = 2
q = a // b # хочется получить 2, как и в прошлый раз, но q = -3
r = a % b # а остаток остался тот же r = 1
Дело в том, что максимальное число, которое можно нацело разделить на число при условии, что остаток будет положительным — это -6. При его делении на 2 получаем -3 и соответствующий остаток, равный 1.

Задание 2.4.1
2/2 points (graded)
Что получится в результате вычислений?

print ((31%2) + (-31 % 2))
2
  верно
print (13%-3*3-3**2)
-15
  верно
Show answer
Отправить
Some problems have options such as save, reset, hints, or show answer. These options follow the Submit button.
Рассмотрим подробное решение задания выше.

Посмотреть решение

Остаток и частное от целочисленного деления
Пусть a делим на b.

Если b > 0

Возьмём целые числа p и q такие, что:

a = p * b + q
0 <= q < b
Если b < 0

Возьмём целые числа p и q такие, что:

a = p * b + q
b < q <= 0
Тогда p — частное от деления: a // bq — остаток от деления: a % b.

В случае с 13 % -3 мы получаем 13 = -5*-3 - 2. Потому что на остаток накладываются ограничения: -3 < q <=0.

Если мы берём остаток от деления числа a на положительное число b, то мы ищем ближайшее снизу к a число, которое делится на b. И вычитаем это число из a.

Например, 13 % 3. Ближайшее снизу число, которое делится на 3, это 12. Тогда остаток 13 % 3 = 13 - 12 = 1.

Если мы берём остаток от деления числа a на отрицательное число b, то ищем ближайшее сверху к a число, которое делится на b. И вычитаем это число из a.

Например, 13 % -3. Ближайшее сверху число, которое делится на 3, это 15. Тогда остаток 13 % 3 = 13 - 15 = -2.

Рассмотрим первое задание:

print ((31 % 2) + (-31 % 2))
Тут мы видим сумму выражений (31 % 2) и (-31 % 2). (31 % 2) — остаток от деления 31 на 2. Получается 1(-31 % 2) — остаток от деления -31 на 2.

Получается тоже 1.

Получили сумму 1 и 1. То есть 2.

Рассмотрим второе задание:

print (13 % -3 * 3 - 3**2)
Тут у нас разность выражений 13 % -3 * 3 и 3**2.

Посмотрим на порядок выполняемых действий в первом выражении (13 % -3) * 3:

(13 % -3) — это -2.
-2 * 3 — это -6.
Второе выражение 3**2 — это 9.

Получили разность чисел -6 и -9. Это -15.

Задание 2.4.2
1/1 point (graded)
Какое действие в последнем примере выполнится последним?
остаток от деления
умножение
вычитание
возведение в степень
верно
Show answer
Отправить
Some problems have options such as save, reset, hints, or show answer. These options follow the Submit button.
Длинная арифметика
Одна из особенностей целых чисел в Python заключается в том, что их точность бесконечна. Иными словами, в целочисленную переменную вы можете записать сколь угодно большие числа, и даже производить операции с ними без какой-либо потери точности.

Например, так:

f = 653457
g = 123493
print(f**g)
# 393354..282257
Полностью записанное число заняло бы неоправданно много места, поэтому большая часть цифр была заменена многоточием. Общее количество цифр, которое необходимо для записи такого числа, равно 718139.

Естественно, время вычисления такой сложной операции будет не маленьким, но такая возможность есть. Она отличает Python от многих других языков, в которых нет встроенной поддержки длинной арифметики.

Например, в языках C и С++ существует несколько встроенных типов для представления целых чисел. Эти типы различаются количеством памяти, которое выделяется на переменные такого типа. В зависимости от этого, переменная имеет ограничение на величину числа, которое можно записать. При попытке записать число, выходящее за границу типов, возможны непредсказуемые последствия.

С одной стороны, встроенная поддержка Python длинной арифметики является преимуществом, с другой стороны, это оборачивается некоторой потерей в производительности при вычислениях. Однако она не на столько критична, чтобы отказываться от такого подхода или не рекомендовать его использовать.

рисунок
Числа с плавающей точкой
С числами плавающей точкой мы тоже уже познакомились. Это термин из Computer science, который относится к вещественным числам, а «плавающая точка» происходит из-за особенностей представления таких чисел в памяти компьютера. В силу этих особенностей общеприняты две записи чисел с плавающей точкой — в десятичной форме и в экспоненциальной.

Десятичная форма нам привычна — сначала записывается целая часть, десятичный разделитель и за ним дробная часть:

a = 5.4321
print(a)
# 5.4321
В результате некоторых операций может случиться так, что число становится очень большим (или очень маленьким), и его трудно представить в десятичном виде. В таком случае на помощь приходит экспоненциальная форма записи числа:

print(a**100)
# 3.138886636534116e+73
Такую запись можно интерпретировать следующим образом. Слева от буквы e находится мантисса. Это обычное дробное число, для которого есть соглашение о том, что оно больше 1 и меньше 10. Справа от буквы e записан порядок числа. Иными словами, это степень числа 10. В таком случае это число можно прочитать как: "3.138886636534116 умножить на 10 в степени 73".

А в общем случае число с плавающей точкой записывается так:

[мантисса]e[показатель <>степени <>числа 10]
Чтобы до конца разобраться с тем, почему же все-таки точка плавающая и куда она может плавать, попробуем умножать и делить полученное число на степени числа 10 (100, 1000):

a = 5.4321**100 # 3.138886636534116e+73

print(a*100) # мантисса осталась прежней, а степень увеличилась на 2
# 3.138886636534116e+75

print(a*1000) # аналогично, только степень увеличилась уже на 3
# 3.138886636534116e+76

print(a/100) # снова мантисса не меняется, а степень уже уменьшилась
# 3.138886636534116e+71

print(a/1000) # как, наверное, уже ожидаемо, степень снова уменьшилась
# 3.138886636534116e+70
Дело в том, что в памяти компьютера мантисса («само» число, его значащие цифры) хранятся отдельно, а показатель степени числа — отдельно. Благодаря этому, умножение на степени числа 10 никак не влияет на мантиссу, прибавляя (или вычитая, в случае деления) соответствующую степень десятки к показателю степени множителя.

Если записать получившиеся числа, приводя их все к одной степени изначального числа — 73, то становится ясным, куда плавает точка:

# 3.138886636534116e+73 - изначально
# 313.8886636534116e+73 - при умножении на 100
# 3138.886636534116e+73 - при умножении на 1000
# 0.03138886636534116e+73 - при делении на 100
# 0.003138886636534116e+73 - при делении на 1000
Точка перемещается влево или вправо по разрядам числа, и поэтому её называют плавающей. А если подходить к этому ещё более формально, можно сказать, что числа с плавающей точкой обладают точной относительной точностью, но изменяющейся абсолютной. Иначе говоря, точность числа содержится в мантиссе (значащих цифрах), а порядок числа становится не важен.

Обратимся также к арифметическим операциям, которые можно применять к числам с плавающей точкой. В целом, они аналогичны операциям над целыми числами, за исключением специфичных операций целочисленного деления и взятия остатка от деления, которые заменяются на привычное деление:

Операция	Обозначение	Пример
Сложение	+	3.14+1 = 4.14
Вычитание	-	3.14-1 = 2.14
Умножение	*	3.14*2 = 6.28
Возведение в степень	**	3.14**2 = 9.8596
Деление	/	3.14/2 = 1.57
Числа с плавающей точкой в отличие от целых чисел не обладают бесконечной точностью. Это обусловлено способом их хранения и выполнения операций над ними.

Рассмотрим такой пример:

print(1/3)
# 0.3333333333333333

Казалось бы, всё хорошо, как и ожидалось. В результате такого деления мы получаем десятичную дробь с бесконечным количеством цифр 3 после запятой. Попросим Python вычислить другое выражение:

print(1.3+2.3)
# 3.5999999999999996
И здесь мы ясно видим, что после 16 знака после запятой вычисления дают сбой, который является естественным для Python. Ответ кроется в том, что для хранения числа используется ограниченное количество памяти (в байтах), которых хватает только на то, чтобы корректно вычислить 16 знаков. Для обхода этой проблемы, если необходимо использовать более точные вычисления, могут использоваться классы Fraction и Decimal. Их рассмотрение выходит за пределы этого модуля, но подробно можно с ними ознакомиться самостоятельно в источниках, указанных ниже.

img   Дополнительно
Официальная документация:

Fractions
Decimal
Дополнительные статьи на русском:

Модуль fractions
Модуль decimal

Давайте вернёмся к заданиям 2.3.4 и 2.3.5 из предыдущего юнита и на более простом примере посмотрим, как программа производит подсчёты.

Задание

Что выведет функция print()?

print (1.2+1.4)
Результат

2.5999999999999996
Пояснение, почему так происходит

В обычной жизни мы используем десятичные дроби. Например, запись числа 1.212 в десятичной системе исчисления:

1 + 2/10 + 1/100 + 2/1000
Это сумма дробей со знаменателями со степенями числа 10:10, 10*10, 10*10*10… Для удобства мы записываем это в виде 1.212.

А если мы попытаемся записать число 1/3 в виде десятичной дроби, то не получим конечную дробь:

0 + 3/10 + 3/100 + 3/1000 + 3/10000 + ...

Каждая запись (например, 0.3333) будет представлять число 1/3 с погрешностью.

Мы знаем, что 1/3 + 1/3 + 1/3 = 1.

Но если мы попытаемся сложить 0.3333 три раза, получим число 0.9999, которое отличается от 1 на 0.0001.
А если попытаемся сложить 0.3333 тридцать раз, то получим число 9.999, что уже отличается от 10 на 0.001.

Резюмируем

Есть числа, которые нельзя записать без погрешности в виде конечной десятичной дроби. При выполнении арифметических операций результаты так же будут с погрешностью, которая возрастает с увеличением количества операций.


Так же с компьютером: он оперирует числами, которые хранятся в виде двоичной конечной дроби. То есть вот в таком виде:

1 + a/2 + b/4 + c/8 +...

Например, число 1.625 (десятичная система) записывается в двоичной системе так:

1 + 1/2 + 0/4 + 1/8

И в компьютере это число будет храниться именно так, в двоичной системе.

Но, когда мы пытаемся записать число 1.2 в двоичной системе исчисления, получаем бесконечную дробь:
1 + 0/2 + 0/4 + 1/8 + 1/16 + 0/32 + 0/64 + 1/128 + 1/256 + 0/512 + 0/1024 + 1/2048 + 1/4096+ 0/8192 + 0/16384 + ...

Так как в памяти компьютера не бесконечно много места, он запишет только часть бесконечной дроби. Например, первые 15 цифр, которые написаны выше:

1.00110011001100

Это число будет отличаться от 1.2 на 0.000048828125. То есть число мы будем хранить с погрешностью.

Аналогично для числа 1.4:
1 + 0/2 + 1/4 + 1/8 + 0/16 + 0/32 + 1/64 + 1/128 + 0/256 + 0/512 + 1/1024 + 1/2048 + 0/4096 + 0/8192 + 1/16384 + ...

Оно запишется в компьютер следующим образом:

1.01100110011001
Что же сделает компьютер, когда мы попросим его вывести на экран полученный результат?

1. Компьютер переведет дробь для числа 1.2 обратно в десятичную:

1.199951171875

Чтобы не пугать пользователя неточностью, компьютер просто округлит полученный результат.

Давайте попробуем сделать это вручную. Например, округлим число выше до четвертой цифры после запятой. Пятая цифра после запятой — 5, поэтому четвертую цифру округляем в большую сторону. Цифра 9 при округлении даст 0, и нужно будет прибавить 1 к цифре, которая стоит перед 9 (в нашем случае это цифра 9, которая стоит на третьей позиции после запятой).

При округлении получается как раз 1.2.

2. Теперь аналогично с числом 1.4:

1.39996337890625

Округляем до четвертой цифры после запятой и получаем 1.4.

3. Просим компьютер сложить два этих числа. Он произведет операцию в двоичной системе:

10.10011001100101

При переводе в десятичную систему это будет дробь:

2.59991455078125

4. Теперь просим компьютер вывести число. Он сначала округляет, но, так как на пятой позиции после запятой стоит 1, четвертая цифра остается без изменений. Получаем:

2.5999

А ожидаемый результат был 2.6.

Вывод

Так происходит, потому что при арифметических операциях складывается погрешность. И погрешности может накопиться столько, что она выйдет за рамки округления.

Это произошло в нашем тренировочном примере. Это происходит и в Python, когда компьютер складывает 1.4 и 1.2.

Преобразование типов
Мы рассмотрели два способа представления чисел в Python: int для целых чисел и float для чисел с плавающей точкой. Python достаточно умный, чтобы понимать, что это два близких друг к другу типа данных.

Мы уже сталкивались с этим, когда пытались делить целые числа друг на друга:

print(3/2)
# 1.5
С одной стороны, изначально мы использовали целые числа. С другой стороны, применяя к ним операцию деления, в результате получили число с плавающей точкой. В данном выражении Python произвёл неявное преобразование типов. Иными словами, во время вычисления оказалось недостаточным использование одних только целых чисел, и они были преобразованы в числа типа float. С другой, но похожей ситуацией, мы уже встречались ранее при обсуждении чисел с плавающей точкой.

Во время вычисления выражения также происходит неявное преобразование типов:

print(3.14*2)
# 6.28
В данном выражении мы умножаем число с плавающей точкой на целое число, которое во время выполнения автоматически преобразуется в число с плавающей точкой.

При вычислении различных выражений Python применяет следующее правило: если в выражении встречается число с плавающей точкой или таковое получается в результате вычисления подвыражений, то результат будет представлен типом float. Такое правило существует для избежания потери данных, содержащихся в дробной части.

Существует также возможность явно преобразовать один тип в другой — приведение типов. Это осуществляется с помощью конструкции:

t(var)
В данном выражении var — это объект, который подлежит преобразованию, а t — это тип (int или float), к которому необходимо преобразовать. Рассмотрим на примерах:

print(float(1))
# 1.0
Аналогично преобразуются числа с плавающей точкой в целые числа:

print(int(3.14))
# 3
Можно подумать, что преобразование из float в int будет приводить к ожидаемым результатам:

print(int(2.8)) # ожидается 3, т.к. 2.8>2.5
# 2
Но ожидания не оправдались. Дело в том, что приведение float к int только отбрасывает дробную часть. Оно не действует как математическое округление.

img   Дополнительно
Про правила округления в математике можно почитать здесь.
Возвращаясь к этому вопросу в Python, хотелось бы обратить на него особое внимание. В совокупности с неточностью чисел с плавающей точкой это может привести к совсем некорректным результатам:

print(1.00+0.01-3.01) # ожидается -2.0
# -1.9999999999999998
Отсутствие точности после определённого знака нами уже обсуждалось и, с учётом этого, пока что всё так, как и должно быть. Попробуем привести результат выражения к целому числу:

print(int(1.00+0.01-3.01))
# -1
рисунок
Мы хотели получить -2, а получили вообще -1! Такая особенность использования различных типов данных и преобразования между ними требует особой аккуратности. А для корректного округления чисел с плавающей точкой по всем правилам необходимо пользоваться функцией round():

print(round(1.00+0.01-3.01))
# -2
С помощью этой функции можно округлять не только до целого числа, но и до желаемого количества знаков после точки:

print(3.14/2)
# 1.57
print(round(3.14/2, 1)) # второй аргумент — желаемое количество знаков
# 1.6
Задание 2.4.3
1/1 point (graded)
Напишите программу, которая вычислит значение выражения 11*2.5/3, округлив до двух знаков после запятой. Впишите результат вычислений:
9.17
  верно
Show answer
Отправить
Some problems have options such as save, reset, hints, or show answer. These options follow the Submit button.
Задание 2.4.4
0/1 point (graded)
Напишите программу, которая вычислит половину квадрата числа Пи (pi=3.14159), округлив до целого. Впишите результат вычислений:
1
  неверно
Отправить
Some problems have options such as save, reset, hints, or show answer. These options follow the Submit button.