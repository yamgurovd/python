"""
Встроенная функция id() позволяет получить число, которое называется идентичностью.
Каждый объект при создании получает некоторое значение идентичности, и оно не может измениться у
одного конкретного объекта во время выполнения программы. Также можно сказать, что это число ассоциируется с адресом
области памяти компьютера, в которой хранится данный объект.

Давайте проверим, так ли это. Скопируйте этот код и запустите его.
"""
L = ['a', 'b', 'c']
print(id(L))

"""
Как можем видеть, результат работы программы соответствует тому, о чём мы говорили ранее.

С помощью функции id() можно увидеть часть механизма, обеспечивающего быстроту работы программ, написанных на Python.

Предположим, что у нас есть две переменные:
"""
a = 5
b = 3+2

"""
Каждая из них имеет значение равное 5, но создаются они совершенно разным образом. Первая — прямым присваиванием числа 5, 
вторая — как результат арифметической операции над другими числами-объектами.

Какое значение идентичности будут иметь объекты данных, хранящиеся в этих переменных?
"""


"""
Удивительно, не правда ли? Дело в том, что некоторые целые числа и строки кешируются в памяти, позволяя не 
создавать каждый раз новый объект. Иными словами, Python при компиляции сам создаёт объекты некоторых видов и 
сохраняет их в памяти. И если в коде встречается «создание» такого объекта, то он подгружается из этой временной памяти.

Рассмотренное нами свойство уникальности каждого объекта используется, в том числе для сравнения объектов с помощью 
ключевого слова is.

Рассмотрим следующий пример:
"""
list_1 = ['a', 'b', 'c']
print(list_1)
list_2 = list_1
print(list_2)
list_3 = list(list_1)
print(list_3)

# Здесь мы можем увидеть (list_1 is list_3) False, потому что list_1 и list_3 указывают на два разных объекта,
# даже если их содержимое может быть одинаковым. Таким образом, мы можем сказать, что «is» вернёт True,
# если две переменные указывают на один и тот же объект, и «==», если объекты, на которые ссылаются переменные, равны.


# При работе со списками есть особенность, которую необходимо рассмотреть.

L = ['Hello', 'world']
M = L

print(M is L)
# True
# Очевидно, что эти списки будут равны по своим значениям (сравнивая через ==). И при таком присваивании в
# M скопируется не сам список L, а его идентификатор! Поэтому, изменяя список M, мы увидим неожиданные изменения в списке L.

M.append('!')

print(L)
# ['Hello', 'world', '!']
# Чтобы избежать такого поворота событий, список нужно копировать.

M = L.copy()

print(M is L)
# False