Перейти к основному содержимому
Для доступа к содержимому необходима запись на курс.
рисунок
В этой части модуля, посвящённого типам данных в Python, мы продолжаем знакомство с различными способами представления данных.

Как мы узнали ранее, в Python все типы данных можно разделить на две группы — изменяемые и неизменяемые. Давайте вспомним какие из них являются изменяемыми, а какие нет.

Задание 2.6.1
1 из 1 балла (оценивается)
 Помощь по управлению с клавиатуры
Задача
Распределите типы данных согласно их свойству изменяемости.

...Изменяемые, зона для перетаскиванияИзменяемые
Элементы, расположенные здесь: Список (list), Словарь (dict), Множество (set)Неизменяемые, зона для перетаскиванияНеизменяемые
Элементы, расположенные здесь: Целое число (int), Число с плавающей точкой (float), Строка (str), Логическая переменная (bool), Кортеж (tuple)
Отправить
Вернуться к началу
Сбросить
Показать ответ
Обратная связь
Correctly placed 8 items.

Your highest score is 1.0

В этом юните будут рассмотрены три основных изменяемых типа данных: списки, словари и множества.

К понятию неизменяемость (unmutable) нужно подходить правильно. Эта характеристика не подразумевает под собой некую константность данных. Строка hello является неизменяемой в том смысле, что любая её модификация будет порождать создание нового объекта, и в этом смысле более точный перевод unmutable — немутирующий. В противоположность этому списки, словари и множества могут изменять свою структуру в существующих объектах, не порождая новые.

Списки
Список — это упорядоченный набор объектов произвольного типа. Иными словами, если переменные, например, целочисленного типа int хранят только одно значение — число, то список может хранить один, два и более объектов. И вообще говоря, может не хранить ни одного объекта — пустой список.

Создание пустого списка происходит присваиванием переменной пустых квадратных скобок:

s = []
При создании такого объекта в памяти резервируется область, в которой хранятся ссылки на элементы списка. Используя схожий синтаксис, можно создать наполнение списка:

s = [0, 'hello', (1, 'a')]
Нами был создан объект типа «список», содержащий три элемента: целое число, строка и кортеж. Как можно заметить, создание списков очень схоже с созданием кортежей, только вместо круглых скобок используются квадратные. Принципиальное отличие между ними заключается в том, что списки можно изменять — добавлять новые объекты и удалять существующие.

Добавление объекта осуществляется с помощью метода append().

Метод — это функция, которая применяется к определённому объекту, используя символ точку:

объект.метод()
Посмотрим, как происходит добавление элементов в массив:

# допустим, у нас есть список, содержащий первые 4 буквы латинского алфавита
letters = ['a', 'b', 'c', 'd']

# с помощью метода append() мы добавляем ещё один элемент в список
letters.append('e')

print(letters)
# ['a', 'b', 'c', 'd', 'e']
В этом частично заключается изменяемость списков. Изначально его размер был равен 4 элементам, но мы его изменили, иными словами он мутировал, и размер стал равен 5 элементам.

Список — это в первую очередь упорядоченная структура данных. Это означает, что каждый элемент списка имеет свой индекс — порядковый номер элемента в списке. Буква "a" — это первая буква латинского алфавита. В списке letters, который мы создали, она также находится на «первом» месте, но если мы захотим получить элемент по его индексу, то натолкнёмся на интересную особенность:

print(letters[1])
# b
Если вы были знакомы с другими языками программирования, то уже знаете, что часто индексация элементов начинается с нуля. Именно это мы и наблюдаем — «первый» элемент на самом деле нулевой (с нулевым индексом):

print(letters[0])
# a
img
Источник: pikabu.ru
Если «первый» элемент списка хранится с индексом 0, то соответственно последний элемент списка будет храниться с индексом на единицу меньше, чем длина массива. Снова обратимся к примеру со списком букв. Его длина равна 5, а индекс последнего элемента будет равен 4:

print(letters[4])
# e
Попытка получить элемент, превышающий эту границу, вызовет ошибку, о чём Python нас предупредит:

print(letters[31])
# IndexError: list index out of range
Как же получить последний элемент списка, если его точная длина заранее неизвестна? Существует два способа. Первый — использование длины списка. Её можно узнать с помощью встроенной функции len(), которая возвращает длину любого итерируемого объекта. К ним относят строки, списки, кортежи и объекты некоторых других типов данных.

С ними подробнее познакомимся в следующих модулях, а пока что можно получать радость от использования такой функции:

print(len(letters))
# 5
Как и ожидалось, длина списка равна 5. Тогда доступ к последнему элементу можно получить, если уменьшить эту длину на 1:

print(letters[len(letters)-1])
# e
По мере изучения языка, мы всё больше будем сталкиваться с большим количеством вложенных конструкций, поэтому к ним нужно постепенно привыкать. В данном случае с помощью len(letters) мы узнали длину списка и уменьшили её на единицу.

Полученное число мы использовали в качестве индекса, записав его в квадратные скобки рядом с названием переменной списка letters[len(letters)-1], после чего вывели полученный элемент в консоль. Такой подход является универсальным, потому что уже нам не нужно знать длину списка во время написания программы.

Если мы добавим ещё какое-то количество элементов в список, такой способ будет продолжать работать:

letters.append('f') # добавляем ещё одну букву
letters.append('g') # и ещё одну

print(letters[len(letters)-1])
# g
Такой способ является решением «в лоб». Однако, согласно философии Python «простое лучше, чем сложное», поэтому есть ещё один подход соответствующий «питоновскому» стилю кода — использование отрицательных индексов:

img
Источник: inf-w.ru
Отрицательные индексы позволяют вывернуть наизнанку список и нумеровать его в обратном порядке. И тогда последний элемент будет иметь индекс -1, предпоследний — -2 и т.д.

Посмотрим на наш список с буквами:

print(letters[-1])
# g
print(letters[-4])
# d
Использование отрицательных индексов для получения элементов с хвоста списка является не только удобным решением, но и рекомендуемым, как соответствующее философии Python.

Изменение структуры списка может происходить не только путем её увеличения (добавления новых объектов), но и удаления уже существующих. Для этого можно использовать метод pop():

print(letters)
# ['a', 'b', 'c', 'd', 'e', 'f', 'g']

letters.pop() # вызов метода без аргументов удаляет последний элемент списка

print(letters)
# ['a', 'b', 'c', 'd', 'e', 'f']
# был удалён последний элемент

letters.pop(0) # или можно удалить элемент по его индексу

print(letters)
# ['b', 'c', 'd', 'e', 'f']
# был удалён нулевой элемент

letters.pop(3) # и необязательно удалять из начала или конца списка

print(letters)
# ['b', 'c', 'd', 'f']
# был удалён элемент с индексом 3
Python не ограничивает мощь своего функционала доступом к элементам по индексам и отрицательным индексам. С помощью срезов можно получать сразу несколько элементов списка.

Срез	Как работает?	Пример
[:]	Возвращает элементы полностью	[‘a’, ‘b’, ‘c’, ‘d’, ‘e’, ‘f’, ‘g’]
[2:]	Возвращает элементы списка, начиная с элемента индекса 2 и до конца списка	[‘c’, ‘d’, ‘e’, ‘f’, ‘g’]
[:3]	Возвращает элементы списка от его начала до элемента с индексом 3, не включая его	[‘a’, ‘b’, ‘c’]
[1:4]	Объединяя предыдущие два способа, можно получить элементы из середины. В данном случае начиная с индекса 1 до индекса 4, не включительно. Иными словами, элементы с индексами 1,2 и 3	[‘b’, ‘c’, ‘d’]
[::2]	Задает шаг, через который извлекаются элементы	[‘a’, ‘c’, ‘e’, ‘g’]
[::-1]	Используя отрицательный шаг, можно развернуть массив	[‘g’, ‘f’, ‘e’, ‘d’, ‘c’, ‘b’, ‘a’]
img   Дополнительно
Методов, которые можно применять к спискам гораздо больше, чем мы рассмотрели здесь. Более подробно с ними можно ознакомиться по ссылке.

Задание 2.6.2
1 возможный балл (оценивается)
 Помощь по управлению с клавиатуры
Установите соответствие между названием и назначением функции:

Длина списка, зона для перетаскиванияДлина списка
Элементы, расположенные здесь: len()Добавить элемент в список, зона для перетаскиванияДобавить элемент в список
Элементы, расположенные здесь: append()Поиск элемента в списке, зона для перетаскиванияПоиск элемента в списке
Элементы, расположенные здесь: index()Удаление элемента из списка, зона для перетаскиванияУдаление элемента из списка
Элементы, расположенные здесь: pop()
Отправить
Вернуться к началу
Сбросить
Показать ответ
Обратная связь
Хорошо! Вы справились с этим заданием.

Задание 2.6.3
4/4 points (graded)
Вместо знаков ??? впишите нужный срез. Найдите оптимальное представление среза.

В качестве ответа на задание укажите только срез, который должен стоять на месте ??? (выписывать всю строку с кодом не следует). Сам срез указывайте без лишних пробелов.

L = ["а", "б", "в", 1, 2, 3, 4]
print (L[ ??? ])
# ["б", "в", 1]
Подсказка
1:4
  верно
L = ["а", "б", "в", 1, 2, 3, 4]
print (L[ ??? ])
# ["а", 1, 4]
Подсказка
::3
  верно
L = ["а", "б", "в", 1, 2, 3, 4]
print (L[ ??? ])
# [1, "в", "б", "а"]
Подсказка
3::-1
  верно
L = ["а", "б", "в", 1, 2, 3, 4]
print (L[ ??? ])
# [4, 3, 2]
Подсказка
Обратите внимание на границы и порядок элементов
:3:-1
  верно
Show answer
Отправить
Some problems have options such as save, reset, hints, or show answer. These options follow the Submit button.
Практический пример
Возможности языка позволяют выполнить определённые действия для каждого элемента списка. Такую операцию можно проделать с помощью функции map():

map(function, list)
Первый аргумент map() — функция, которую нужно применить к каждому элементу списка, а сам список — второй аргумент. Возвращаемое значение этой функции — объект map, который можно преобразовать, например, обратно в список.

Рассмотрим пример:

# имеем список с числами с плавающей точкой
L = [3.3, 4.4, 5.5, 6.6]

# печатаем сам объект map
print(map(round, L)) # к каждому элементу применяем функцию округления
# <map object at 0x7fd7e86eb6a0>

# и результат его преобразования в список
print(list(map(round, L)))
# [3, 4, 6, 7]
Задание 2.6.4
1/1 point (graded)
Вставьте вместо знаков ??? требуемое слово.

Программа должна преобразовать список строковых представлений чисел в объекты численного типа данных. Для этого вспомните, как мы выполняли преобразование одиночных объектов из строк в числа.
L = ['3.3', '4.4', '5.5', '6.6']

print (list (map ( ??? , L)))
float
  верно
Show answer
Отправить
Some problems have options such as save, reset, hints, or show answer. These options follow the Submit button.
Область применения функции очень большая, но мы остановимся на одном её применении — ввод данных. Вспомним, что даже при вводе чисел во время выполнения функции input(), они все равно остаются в строковом представлении. Если ввести сразу несколько чисел через пробел, то тем более они останутся в таком виде.

Однако, пользуясь функциями split() и map(), можно выполнить нужное преобразование:

string = input("Введите числа через пробел:")

list_of_strings = string.split() # список строковых представлений чисел
list_of_numbers = list(map(int, list_of_strings)) # cписок чисел

print(sum(list_of_numbers[::3])) # sum() вычисляет сумму элементов списка
Задание 2.6.5
1/1 point (graded)
Что напечатает программа, если на вход программы ввести следующее:

1 1 2 3 5 8 13 21 34 55
72
  верно
Show answer
Отправить
Some problems have options such as save, reset, hints, or show answer. These options follow the Submit button.
Задание 2.6.6
Напишите программу, которая на вход получает последовательность чисел, а выводит модифицированный список:

Первое и последнее числа последовательности должны поменяться местами.
В конец списка нужно добавить сумму всех чисел.
Посмотреть ответ для самопроверки
Задание 2.6.7
1/1 point (graded)
Чему будет равен последний элемент списка, полученного в результате работы алгоритма из последней задачи, если на вход подается последовательность чисел:

1 1 2 3 5 8 13 21 34 55
143.0
  верно
Show answer
Отправить
Some problems have options such as save, reset, hints, or show answer. These options follow the Submit button.
Словари
Использование списков открывает много возможностей, но и имеет свои ограничения. Каждому элементу списка присваивается целочисленный индекс, по которому можно обращаться к нему, модифицировать и даже удалять. С другой стороны, использование целочисленного индекса не является всегда удобным.

Например, если мы хотим в одной переменной хранить информацию о человеке (имя, фамилию, электронную почту, номер телефона, почтовый адрес), то нумерация является неудобной и малоинформативной. Более того, в таком случае не принципиален и порядок этих данных — главное, чтобы к ним можно было удобно обратиться.

Для этой цели в Python предусмотрены словари (dict) — упорядоченные наборы объектов, доступных по ключу. Иными словами, словарь — это совокупность пар ключ-объект.

Сам объект, который хранится в словаре, может быть любым. Даже другим словарём. Но на ключи есть важное ограничение: ключ может быть только объектом неизменяемых типов данных, т.е. числом, строкой или кортежем.

Как и в случае списков, словарь можно создать пустым, можно сразу наполнить его объектами, а можно расширять постепенно:

person = {} # с помощью фигурных скобок можно создать словарь

# словарь заполняется по принципу — ключ:объект (через двоеточие)
person = {'name' : 'Ivan Petrov'}

# в него можно также добавлять новые объекты по ключу
person['age'] = 25
person['email'] = 'ivan_petrov@example.com'
person['phone'] = '8(800)555-35-35'

print(person)
# {'name': 'Ivan Petrov', 'age': 25, 'email': 'ivan_petrov@example.com', 'phone': '8(800)555-35-35'}
Попытка извлечения объекта по несуществующему ключу приведёт к ошибке:

print(person['address'])
# KeyError: 'address'
Можно отдельно получить список ключей:

print(person.keys())
# dict_keys(['name', 'age', 'email', 'phone'])
Или список значений:

print(person.values())
# dict_values(['Ivan Petrov', 25, 'ivan_petrov@example.com', '8(800)555-35-35'])
Из словаря аналогично спискам можно удалить объект по его ключу. Словарь является упорядоченным. В функцию pop() всегда нужно передавать ключ удаляемого объекта:

print(person)
# {'name': 'Ivan Petrov', 'age': 25, 'email': 'ivan_petrov@example.com', 'phone': '8(800)555-35-35'}

person.pop('phone')

print(person)
# {'name': 'Ivan Petrov', 'age': 25, 'email': 'ivan_petrov@example.com'}
Задание 2.6.8
1/1 point (graded)
Какой из перечисленных объектов не может быть ключом в словаре?
42
['id', 42]
'id'
('id', 42)
верно
Show answer
Отправить
Some problems have options such as save, reset, hints, or show answer. These options follow the Submit button.
Задание 2.6.9
1/1 point (graded)
Вместо знаков ??? вставьте название функции, которая удаляет объект из словаря по его ключу.

d.??? ('key')
pop
  верно
Show answer
Отправить
Some problems have options such as save, reset, hints, or show answer. These options follow the Submit button.
Задание 2.6.10
1/1 point (graded)
Что выведет программа? Впишите получившуюся строку без использования кавычек.

d = {'day' : 22, 'month' : 6, 'year' : 2015}

print("||".join(d.keys()))
day||month||year
  верно
Show answer
Отправить
Some problems have options such as save, reset, hints, or show answer. These options follow the Submit button.
Задание 2.6.11 (External resource)

Посмотреть ответ для самопроверки
Практический пример
Использование списков и словарей по отдельности обеспечивает удобный и эффективный способ хранения данных, а их совместное использование открывает ещё больше возможностей.

Рассмотрим, как может храниться база данных абитуриентов, поступающих в университет. Информация о каждом абитуриенте может храниться в виде словаря с ключами ФИО, Количество баллов, Заявление (о согласии на зачисление):

abit1 = {"ФИО" : 'Фадеев О.Е.', "Количество баллов" : 283, "Заявление" : True}
abit2 = {"ФИО" : 'Дружинин И.Я.', "Количество баллов" : 278, "Заявление" : False}
abit3 = {"ФИО" : 'Афанасьев Д.Н.', "Количество баллов" : 276, "Заявление" : True}


abits = [abit1, abit2, abit3]

print(abits)
# [{'ФИО': 'Фадеев О.Е.', 'Количество баллов': 283, 'Заявление': True}, {'ФИО': 'Дружинин И.Я.', 'Количество баллов': 278, 'Заявление': False}, {'ФИО': 'Афанасьев Д.Н.', 'Количество баллов': 276, 'Заявление': True}]
Этот список по мере поступления документов можно пополнять:

abit4 = {"ФИО" : 'Любимчиков А.Я.', "Количество баллов" : 269, "Заявление" : True}

abits.append(abit4)

print(abits)
# [{'ФИО': 'Фадеев О.Е.', 'Количество баллов': 283, 'Заявление': True}, {'ФИО': 'Дружинин И.Я.', 'Количество баллов': 278, 'Заявление': False}, {'ФИО': 'Афанасьев Д.Н.', 'Количество баллов': 276, 'Заявление': True}, {'ФИО': 'Любимчиков А.Я.', 'Количество баллов': 269, 'Заявление': True}]
Использование списка словарей с одним и тем же набором ключей позволяет обрабатывать все эти данные целиком, например, ранжировать по количеству баллов или фильтровать по наличию заявления. В следующих модулях мы научимся выполнять такие операции.

Уникальные элементы списка
Представим, что у нас есть список номеров и абонентов мобильного оператора, которым принадлежат эти номера. Всегда найдутся люди, на которых зарегистрировано несколько номеров. В таком случае в списке номеров-абонентов данные клиентов будут повторяться. Однако, например, для анализа клиентской базы может понадобиться выделить из общего списка только уникальные данные (скажем, уникальные фамилии).

Можно подойти к этой задаче с помощью циклов, пробегая по каждому элементу исходного списка и добавляя в новый только уникальные элементы. Уже звучит так, что для, казалось бы, такой простой операции нужно написать много кода. Не правда ли? Это правда. Руководствуясь философией Python — простое лучше, чем сложное, — хотелось бы иметь более простой способ это сделать. И он есть!

Для решения практических задач такого рода в Python есть ещё один изменяемый тип данных, который мы упоминали, но подробно не разбирали — множества (set).

Множество — это неупорядоченный набор уникальных элементов. Иными словами, во множествах не могут повторяться элементы, а хранятся они в памяти компьютера в произвольном порядке.

Создать множество можно несколькими способами:

a = {'a', 'b', 'c', 'd'} # используя синтаксис { }
Или, что нам будет более полезно, множество можно создать из списка с помощью приведения типов:

L = [1,1,2,3,2]

b = set(L)

print(b)
# {1,2,3}
В начале мы имели список из 5 элементов, два из которых встречались дважды. «Обернув» исходный список в множество, мы получили только уникальные элементы! И не потребовалось писать много строк кода, чтобы это сделать. Осталось только множество вернуть обратно в списковое представление, опять же используя явное приведение типов.

b_list = list(b)

print(b_list)
# [1,2,3]
А для краткости все эти операции можно записать в одну строку, ведь в Python естественным образом заложена лаконичность кода.

c = list(set(L))

print(c)
# [1,2,3]
Задание 2.6.12
Задание на самопроверку.

Напишите программу, которая на вход принимает текст и выводит количество уникальных символов.

Решение
2.6.13
0 points possible (ungraded)
Используя алгоритм из прошлой задачи, найдите количество уникальных символов в тексте. Скопируйте его к себе в консоль целиком.

The Zen of PythonBeautiful is better than ugly.Explicit is better than implicit.Simple is better than complex.Complex is better than complicated.Flat is better than nested.Sparse is better than dense.Readability counts.Special cases aren't special enough to break the rules.Although practicality beats purity.Errors should never pass silently.Unless explicitly silenced.In the face of ambiguity, refuse the temptation to guess.There should be one-- and preferably only one --obvious way to do it.Although that way may not be obvious at first unless you're Dutch.Now is better than never.Although never is often better than *right* now.If the implementation is hard to explain, it's a bad idea.If the implementation is easy to explain, it may be a good idea.Namespaces are one honking great idea -- let's do more of those!
44
  верно

Show answer
Отправить
Some problems have options such as save, reset, hints, or show answer. These options follow the Submit button.
Множества в Python аналогичны математическим множествам, поэтому для них существует несколько собственных операций.

Операция	Название	Смысл
set.union(other)	Объединение	Возвращает множество, состоящее из элементов set и other.
set.intersection(other)	Пересечение	Возвращает множество, состоящее из элементов, которые встречаются и в set, и в other.
set.difference(other)	Разность	Возвращает множество элементов set, которые не встречаются в other.
set.symmetric_difference(other)	Симметричная разность	Возвращает множество элементов, встречающиеся в одном из множеств, но не в обоих одновременно.
Чтобы не ходить далеко за примером, вернёмся к базе абонентов мобильного оператора. Пусть у нас есть множество абонентов (для простоты — фамилии) и множество должников, а мы хотим получить множество абонентов, не имеющих долгов.

abons = {"Иванов", "Петров", "Васильев", "Антонов"}

debtors = {"Петров", "Антонов"}

non_debtors = abons.difference(debtors)

print(non_debtors)
# {'Васильев', 'Иванов'}
2.6.14
0 points possible (ungraded)
Найдите ошибку в коде, исправьте и укажите в поле ответа скорректированную строку полностью. Представленная ниже программа должна находить множество символов, которые встречаются в двух строках одновременно.

a = input("Введите первую строку: ")
b = input("Введите вторую строку: ")

a_set, b_set = set(a), set(b) # используем множественное присваивание

a_and_b = a_set.union(b_set)

print(a_and_b)
a_and_b = a_set.intersection(b_set)
  верно
Show answer
Отправить
Some problems have options such as save, reset, hints, or show answer. These options follow the Submit button.
2.6.15
0 points possible (ungraded)
Напишите программу, которая на вход получает две последовательности целых чисел, а возвращает список элементов, встречающихся только в первой или во второй последовательности, но не в двух одновременно. Какую операцию над множествами вы использовали?
Как и в предыдущем задании, нужно подобрать подходящую функцию множества. Выглядеть это будет так: set.something(other), где something и есть выбранная вами функция. Именно её нужно ввести в поле ответа. Обратите внимание: необходимо указать только название функции, без скобок.

symmetric_difference
  верно
Show answer
Отправить
Some problems have options such as save, reset, hints, or show answer. These options follow the Submit button.
Проверьте себя
Напишите числа в порядке возрастания через пробел, которые выведет программа из предыдущего задания, если на вход подаются две последовательности чисел:

1 2 3 4 5 6 7 8
2 4 6 8 10 12
Ответ
