# Тема урока: условный оператор

1. Вложенные условия
2. Каскадные условия
3. Решение задач

`Аннотация`. Изучим вложенный и каскадный условный оператор.

## Вложенный оператор

Внутри условного оператора можно использовать любые инструкции языка Python, в том числе и условный оператор. Получаем
вложенное ветвление: после одной развилки в ходе исполнения программы появляется другая развилка. При этом вложенные
блоки имеют больший размер отступа (+4 пробела для каждого следующего уровня).

```python
if условие1:
    блок
    кода
else:
    if условие2:
        блок
        кода
    else:
        if условие3:
            блок
            кода
        ...
```

В предыдущем уроке мы разбирали задачу об определении координатной четверти точки. Программу можно переписать с
использованием вложенного оператора:

```python
x = int(input())
y = int(input())

if x > 0:
    if y > 0:
        print('Первая четверть')
    else:
        print('Четвертая четверть')
else:
    if y > 0:
        print('Вторая четверть')
    else:
        print('Третья четверть')
```

В данном случае уровень вложенности равен двум, так что программа одинаково хорошо читается как с помощью использования
логического оператора and, так и с помощью вложенного оператора.

Рассмотрим программу, которая переводит стобалльную оценку в пятибалльную. Для ее реализации нужно воспользоваться
вложенным условным оператором:

```python
grade = int(input('Введите вашу отметку по 100-балльной системе: '))

if grade >= 90:
    print(5)
else:
    if grade >= 80:
        print(4)
    else:
        if grade >= 70:
            print(3)
        else:
            if grade >= 60:
                print(2)
            else:
                print(1)
```

В этом примере уровень вложенности настолько глубок, что код становится трудно понять.

Выбор из нескольких альтернатив – это обычное дело, здесь имеет смысл избегать глубокого вложения. Для этого в Python
есть `каскадный условный оператор`.

Мы не могли написать 5 независимых if-ов, поскольку в таком случае было бы напечатано сразу несколько значений
пятибалльной оценки.

## Каскадный условный оператор

Если требуется проверить несколько условий, в языке Python используется каскадный условный оператор.

Синтаксис каскадного условного оператора имеет следующий вид:

```python
if условие1:
    блок
    кода
elif условие2:
    блок
    кода
...
else:
блок
кода
```

!["Dbeaver"](/stepic/beginers/2 if_else/4_3/image1.png)

При исполнении такого условного оператора сначала проверяется условие1. Если оно является истинным, то исполняется блок
кода, который следует сразу после него, вплоть до выражения `elif`. Остальная часть конструкции игнорируется. Однако
если
условие1 является ложным, то программа перескакивает непосредственно к следующему выражению `elif` и проверяет условие2.
Если оно истинное, то исполняется блок кода, который следует сразу после него, вплоть до следующего выражения `elif`. И
остальная часть условного оператора тогда игнорируется. Этот процесс продолжается до тех пор, пока не будет найдено
условие, которое является истинным, либо пока больше не останется выражений `elif`. Если ни одно условие не является
истинным, то исполняется блок кода после выражения `else`.

Приведенный ниже фрагмент кода является примером каскадного условного оператора `if-elif-else`. Этот фрагмент кода
работает
так же, как предыдущий код, использующий вложенный условный оператор.

```python
grade = int(input('Введите вашу отметку: '))

if grade >= 90:
    print(5)
elif grade >= 80:
    print(4)
elif grade >= 70:
    print(3)
elif grade >= 60:
    print(2)
else:
    print(1)
```

Обратите внимание на выравнивание и выделение отступом, которые применены в инструкции `if-elif-else`: выражения `if`,
`elif`
и `else` выравнены и исполняемые по условию блоки выделены отступом.

Инструкция `if-elif-else` не является обязательной, потому что ее логика может быть запрограммирована вложенными
инструкциями `if-else`. Однако длинная серия вложенных инструкций` if-else` имеет два характерных недостатка:

программный код может стать сложным и трудным для восприятия;
из-за необходимого выделения отступом продолжительная серия вложенных инструкций `if-else` может стать слишком длинной,
чтобы целиком уместиться на экране монитора без горизонтальной прокрутки.
Логика инструкции `if-elif-else` обычно прослеживается легче, чем длинная серия вложенных инструкций `if-else`. И
поскольку
в инструкции `if-elif-else` все выражения выровнены, длина строк в данной инструкции, как правило, короче.

`Запомни`. Заключительный блок else в операторе `if-elif-else` является необязательным:

```python
traffic_light_signal = input('Введите сигнал светофора: ')

if traffic_light_signal == 'красный':
    print('Стой!')
elif traffic_light_signal == 'желтый':
    print('Приготовься...')
elif traffic_light_signal == 'зеленый':
    print('Иди!')
```

В данном случае если будет введен некорректный сигнал светофора, программа ничего не выведет. Каждое условие будет
проверено поочередно, и программа завершится без ошибок.

                             